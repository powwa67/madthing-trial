<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>SHADOW RANKER</title>
    <link href="https://fonts.googleapis.com/css2?family=Russo+One&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0; background-color: #050505; overflow: hidden;
            font-family: 'Russo One', sans-serif;
            user-select: none;
        }
        canvas { display: block; }
        
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
        }

        /* --- HUD --- */
        #hud-top {
            display: flex; justify-content: space-between; padding: 20px;
            text-transform: uppercase; color: #fff;
        }
        .bar-container {
            width: 300px; height: 20px; background: #222; border: 2px solid #fff;
            transform: skew(-15deg); position: relative; margin-bottom: 5px;
        }
        #hp-bar { width: 100%; height: 100%; background: #ff0044; transition: width 0.1s; }
        #xp-bar { width: 0%; height: 100%; background: #00aaff; transition: width 0.2s; }
        
        #level-indicator {
            font-size: 2rem; color: #00aaff; text-shadow: 0 0 10px #00aaff;
        }

        /* --- MENUS --- */
        .modal {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); display: flex; flex-direction: column;
            justify-content: center; align-items: center; pointer-events: auto;
            backdrop-filter: blur(5px); z-index: 50;
        }
        
        .card-container {
            display: flex; gap: 20px; margin-top: 30px;
        }
        
        .perk-card {
            background: linear-gradient(180deg, #111, #001122);
            border: 2px solid #00aaff; width: 180px; padding: 20px;
            text-align: center; cursor: pointer; transition: transform 0.2s;
            box-shadow: 0 0 15px rgba(0, 170, 255, 0.2);
        }
        .perk-card:hover { transform: scale(1.05); background: #002244; }
        .perk-title { color: #00aaff; font-size: 1.2rem; margin-bottom: 10px; }
        .perk-desc { color: #aaa; font-size: 0.9rem; }

        .btn {
            background: #fff; color: #000; border: none; padding: 15px 40px;
            font-family: 'Russo One'; font-size: 1.5rem; cursor: pointer;
            transform: skew(-10deg); transition: all 0.1s; margin-top: 20px;
        }
        .btn:active { transform: skew(-10deg) scale(0.95); }
        .btn-start { background: linear-gradient(90deg, #00aaff, #0055ff); color: #fff; }

        .dmg-text {
            position: absolute; font-size: 1.2rem; font-weight: bold;
            animation: floatUp 0.8s forwards; pointer-events: none;
            text-shadow: 2px 2px 0 #000;
        }
        @keyframes floatUp { 0% { opacity:1; transform:translateY(0); } 100% { opacity:0; transform:translateY(-50px); } }

        #key-box {
            background: #000; border: 1px dashed #00ff00; color: #00ff00;
            padding: 15px; margin-top: 20px; font-family: monospace;
            max-width: 90%; word-break: break-all;
        }
        
        .tutorial {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            color: #555; font-size: 0.9rem;
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div id="hud-top" style="display:none;">
            <div>
                <div class="bar-container"><div id="hp-bar"></div></div>
                <div style="color:#ff0044; font-size:0.8rem;">HP</div>
            </div>
            <div style="text-align: right;">
                <div id="level-indicator">RANK: E</div>
                <div class="bar-container" style="border-color:#005588;"><div id="xp-bar"></div></div>
                <div style="color:#00aaff; font-size:0.8rem;">AWAKENING PROGRESS</div>
            </div>
        </div>
        <div id="damage-layer"></div>
        <div id="tutorial-txt" class="tutorial" style="display:none;">
            [A/D] MOVE &nbsp;&nbsp; [SPACE] ATTACK &nbsp;&nbsp; [SHIFT] DASH
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <div id="start-screen" class="modal">
        <h1 style="font-size: 4rem; color: #fff; margin:0; text-shadow: 0 0 20px #00aaff;">SHADOW<br>RANKER</h1>
        <p style="color:#888;">SURVIVE. AWAKEN. CLAIM THE SYSTEM REWARD.</p>
        <button class="btn btn-start" onclick="startGame()">ENTER DUNGEON</button>
    </div>

    <div id="levelup-screen" class="modal" style="display:none;">
        <h1 style="color: #ffcc00; text-shadow: 0 0 20px #ffaa00;">LEVEL UP!</h1>
        <p style="color: #fff;">CHOOSE YOUR BLESSING</p>
        <div class="card-container" id="perk-container">
            </div>
    </div>

    <div id="death-screen" class="modal" style="display:none;">
        <h1 style="color: #ff0044;">YOU DIED</h1>
        <button class="btn" onclick="location.reload()">RETRY</button>
    </div>

    <div id="win-screen" class="modal" style="display:none;">
        <h1 style="color: #00ff00; text-shadow: 0 0 20px #00ff00;">S-RANK ACHIEVED</h1>
        <p style="color: #fff;">SYSTEM ACCESS GRANTED</p>
        <div id="key-box">CONNECTING...</div>
        <button class="btn" onclick="copyKey()">COPY KEY</button>
    </div>

    <script>
        // --- CONFIGURATION ---
        const WORKER_URL = "https://powa-vault.powwa.workers.dev";
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        let width, height;
        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
        }
        window.addEventListener('resize', resize);
        resize();

        // --- GAME STATE ---
        let gameState = 'MENU'; // MENU, PLAY, PAUSE, OVER, WIN
        let frames = 0;
        let groundY = height - 100;
        
        let damageLayer = document.getElementById('damage-layer');

        const player = {
            x: 0, y: 0, 
            vx: 0, vy: 0,
            width: 40, height: 80,
            color: '#00aaff',
            facing: 1, // 1 right, -1 left
            
            // RPG Stats
            level: 1,
            xp: 0,
            maxXp: 100,
            hp: 100,
            maxHp: 100,
            attack: 15,
            speed: 6,
            dashCooldown: 0,
            
            // Animation States
            attacking: false,
            attackTimer: 0,
            dashing: false
        };

        let enemies = [];
        let particles = [];
        let shake = 0;
        let keys = {};
        
        // --- INPUTS ---
        window.addEventListener('keydown', e => {
            keys[e.code] = true;
            if(e.code === 'Space' && gameState === 'PLAY') playerAttack();
            if(e.code === 'ShiftLeft' && gameState === 'PLAY') playerDash();
        });
        window.addEventListener('keyup', e => keys[e.code] = false);

        // --- CORE FUNCTIONS ---
        function startGame() {
            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('hud-top').style.display = 'flex';
            document.getElementById('tutorial-txt').style.display = 'block';
            
            player.x = width / 2;
            player.y = groundY - player.height;
            player.hp = player.maxHp;
            
            gameState = 'PLAY';
            loop();
        }

        function spawnEnemy() {
            let side = Math.random() < 0.5 ? -50 : width + 50;
            let type = 'MINION';
            let size = 40;
            let hp = 30 + (player.level * 10);
            let speed = 2 + (Math.random() * 2);
            let color = '#ff0044';
            let dmg = 5 + player.level;

            if (player.level > 2 && Math.random() < 0.2) {
                type = 'TANK'; size = 70; hp *= 3; speed *= 0.5; color = '#aa0000'; dmg *= 2;
            }
            if (player.level > 3 && Math.random() < 0.1) {
                type = 'ASSASSIN'; size = 30; hp *= 0.8; speed *= 2.5; color = '#ff5500';
            }

            enemies.push({
                x: side,
                y: groundY - size,
                width: size, height: size * 2,
                hp: hp, maxHp: hp,
                damage: dmg,
                speed: speed,
                color: color,
                type: type,
                vx: 0, hitTimer: 0
            });
        }

        function playerAttack() {
            if (player.attacking) return;
            player.attacking = true;
            player.attackTimer = 15; // Frames the hitbox is active
            
            // Attack Dash (Little lunge)
            player.vx = player.facing * 10; 
            
            // Create "Slash" effect
            particles.push({
                type: 'slash',
                x: player.x + (player.facing * 40),
                y: player.y + 20,
                life: 10,
                facing: player.facing
            });

            // Check Hitbox immediately
            let hitCount = 0;
            let range = 120;
            
            enemies.forEach(e => {
                let dist = (e.x - player.x) * player.facing;
                if (dist > 0 && dist < range && Math.abs(e.y - player.y) < 50) {
                    // HIT!
                    hitCount++;
                    let crit = Math.random() < 0.2 ? 2 : 1;
                    let dmg = Math.floor(player.attack * crit);
                    e.hp -= dmg;
                    e.hitTimer = 10;
                    e.x += player.facing * 40; // Knockback
                    
                    spawnDamageText(e.x, e.y, dmg, crit > 1);
                    screenShake(5);
                    
                    // Blood Particles
                    for(let i=0; i<5; i++) {
                        particles.push({
                            type: 'blood', x: e.x + e.width/2, y: e.y + e.height/2,
                            vx: (Math.random()-0.5)*10, vy: (Math.random()-0.5)*10,
                            life: 20, color: e.color
                        });
                    }

                    if (e.hp <= 0) {
                        gainXp(e.type === 'TANK' ? 50 : 20);
                    }
                }
            });
        }
        
        function playerDash() {
            if(player.dashCooldown > 0) return;
            player.dashing = true;
            player.dashCooldown = 60;
            player.vx = player.facing * 25;
            
            // Ghost trail effect
            for(let i=0; i<5; i++) {
                setTimeout(() => {
                    particles.push({
                        type: 'afterimage', x: player.x, y: player.y,
                        width: player.width, height: player.height,
                        life: 10, opacity: 0.5
                    });
                }, i * 50);
            }
        }

        function gainXp(amount) {
            player.xp += amount;
            if (player.xp >= player.maxXp) {
                levelUp();
            }
            updateHud();
        }

        function updateHud() {
            let hpPct = Math.max(0, (player.hp / player.maxHp) * 100);
            document.getElementById('hp-bar').style.width = hpPct + "%";
            
            let xpPct = Math.min(100, (player.xp / player.maxXp) * 100);
            document.getElementById('xp-bar').style.width = xpPct + "%";
            
            // Ranks: E, D, C, B, A, S
            const ranks = ['E', 'D', 'C', 'B', 'A', 'S'];
            let rank = ranks[Math.min(player.level-1, 5)];
            document.getElementById('level-indicator').innerText = `RANK: ${rank}`;
        }

        function levelUp() {
            player.level++;
            player.xp = 0;
            player.maxXp = Math.floor(player.maxXp * 1.5);
            
            // Check Win
            if (player.level > 5) {
                winGame();
                return;
            }

            gameState = 'PAUSE';
            
            // Generate Perks
            const perks = [
                { title: "STRENGTH UP", desc: "+10 DAMAGE", action: () => { player.attack += 10; } },
                { title: "FULL RECOVERY", desc: "HEAL 100% HP + MAX HP", action: () => { player.maxHp += 50; player.hp = player.maxHp; } },
                { title: "AGILITY", desc: "+SPEED & DASH CD", action: () => { player.speed += 2; player.dashCooldown = 0; } }
            ];
            
            let container = document.getElementById('perk-container');
            container.innerHTML = '';
            
            perks.forEach(p => {
                let card = document.createElement('div');
                card.className = 'perk-card';
                card.innerHTML = `<div class="perk-title">${p.title}</div><div class="perk-desc">${p.desc}</div>`;
                card.onclick = () => {
                    p.action();
                    document.getElementById('levelup-screen').style.display = 'none';
                    gameState = 'PLAY';
                    updateHud();
                };
                container.appendChild(card);
            });

            document.getElementById('levelup-screen').style.display = 'flex';
        }

        function spawnDamageText(x, y, dmg, isCrit) {
            let el = document.createElement('div');
            el.className = 'dmg-text';
            el.innerText = dmg;
            el.style.left = (x + Math.random()*20) + 'px';
            el.style.top = (y - 20) + 'px';
            el.style.color = isCrit ? '#ffcc00' : '#fff';
            if (isCrit) { el.style.fontSize = '2rem'; el.innerText += "!"; }
            damageLayer.appendChild(el);
            setTimeout(() => el.remove(), 800);
        }

        function screenShake(amount) {
            shake = amount;
        }

        // --- GAME LOOP ---
        function update() {
            if (shake > 0) shake *= 0.9;
            if (shake < 0.5) shake = 0;

            // Player Physics
            if (keys['KeyA'] || keys['ArrowLeft']) {
                player.vx -= 1;
                player.facing = -1;
            } else if (keys['KeyD'] || keys['ArrowRight']) {
                player.vx += 1;
                player.facing = 1;
            } else {
                player.vx *= 0.8; // Friction
            }
            
            // Speed Clamp
            let maxSpd = player.dashing ? 20 : player.speed;
            if (player.vx > maxSpd) player.vx = maxSpd;
            if (player.vx < -maxSpd) player.vx = -maxSpd;
            
            player.x += player.vx;
            
            // Bounds
            if (player.x < 0) player.x = 0;
            if (player.x > width - player.width) player.x = width - player.width;

            // Timers
            if (player.attackTimer > 0) player.attackTimer--;
            else player.attacking = false;
            
            if (player.dashCooldown > 0) player.dashCooldown--;
            if (player.dashCooldown < 50) player.dashing = false;

            // Enemies
            // Spawn logic
            if (frames % 120 === 0 && enemies.length < 5 + player.level) {
                spawnEnemy();
            }

            enemies.forEach((e, index) => {
                if (e.hp <= 0) {
                    enemies.splice(index, 1);
                    return;
                }

                // AI: Move to player
                if (e.hitTimer > 0) {
                    e.hitTimer--; // Stunned
                } else {
                    let dir = player.x > e.x ? 1 : -1;
                    e.x += dir * e.speed;
                    
                    // Attack Player
                    if (Math.abs(player.x - e.x) < 50 && Math.abs(player.y - e.y) < 50) {
                        if (frames % 30 === 0 && !player.dashing) {
                            player.hp -= e.damage;
                            screenShake(3);
                            spawnDamageText(player.x, player.y, -e.damage, false);
                            updateHud();
                            if (player.hp <= 0) die();
                        }
                    }
                }
            });

            // Particles
            particles = particles.filter(p => {
                if (p.type === 'blood') {
                    p.x += p.vx; p.y += p.vy; p.vy += 0.5; // Gravity
                }
                p.life--;
                return p.life > 0;
            });
            
            frames++;
        }

        function draw() {
            ctx.fillStyle = "#050505";
            ctx.fillRect(0, 0, width, height);
            
            ctx.save();
            // Camera Shake
            if (shake > 0) {
                ctx.translate((Math.random()-0.5)*shake, (Math.random()-0.5)*shake);
            }

            // Ground
            ctx.fillStyle = "#111";
            ctx.fillRect(0, groundY, width, height - groundY);
            ctx.strokeStyle = "#333";
            ctx.beginPath(); ctx.moveTo(0, groundY); ctx.lineTo(width, groundY); ctx.stroke();

            // Draw Player (Stickman Style)
            drawStickman(player.x + player.width/2, player.y + player.height, player.color, player.facing, true);

            // Draw Enemies
            enemies.forEach(e => {
                let flash = e.hitTimer > 0;
                drawStickman(e.x + e.width/2, e.y + e.height, flash ? '#fff' : e.color, player.x > e.x ? 1 : -1, false);
                
                // HP Bar
                ctx.fillStyle = "red";
                ctx.fillRect(e.x, e.y - 10, e.width, 5);
                ctx.fillStyle = "#0f0";
                ctx.fillRect(e.x, e.y - 10, e.width * (e.hp/e.maxHp), 5);
            });

            // Particles
            particles.forEach(p => {
                if (p.type === 'slash') {
                    ctx.strokeStyle = "#00ffff";
                    ctx.lineWidth = 4;
                    ctx.shadowBlur = 20; ctx.shadowColor = "#00ffff";
                    ctx.beginPath();
                    let cx = p.x; let cy = p.y;
                    ctx.arc(cx, cy, 60, p.facing === 1 ? -1 : 2, p.facing === 1 ? 1 : 4);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                } else if (p.type === 'blood') {
                    ctx.fillStyle = p.color;
                    ctx.fillRect(p.x, p.y, 4, 4);
                } else if (p.type === 'afterimage') {
                    ctx.globalAlpha = 0.2;
                    drawStickman(p.x + p.width/2, p.y + p.height, '#00aaff', player.facing, true);
                    ctx.globalAlpha = 1.0;
                }
            });

            ctx.restore();
        }

        function drawStickman(cx, cy, color, facing, isPlayer) {
            // cx, cy is bottom center feet
            ctx.strokeStyle = color;
            ctx.lineWidth = 4;
            ctx.lineCap = "round";
            ctx.shadowBlur = 10; ctx.shadowColor = color;
            
            let hipY = cy - 30;
            let shoulderY = cy - 60;
            let headY = cy - 70;

            ctx.beginPath();
            
            // Legs
            let runOffset = isPlayer && Math.abs(player.vx) > 0.1 ? Math.sin(frames * 0.5) * 10 : 0;
            ctx.moveTo(cx, hipY); ctx.lineTo(cx - 10 + runOffset, cy); // Left Leg
            ctx.moveTo(cx, hipY); ctx.lineTo(cx + 10 - runOffset, cy); // Right Leg
            
            // Torso
            ctx.moveTo(cx, hipY); ctx.lineTo(cx, shoulderY);

            // Arms
            let armOffset = 0;
            if (isPlayer && player.attacking) armOffset = -20; // Raise arm
            
            ctx.moveTo(cx, shoulderY); ctx.lineTo(cx - 15 * facing, shoulderY + 20); // Back Arm
            ctx.moveTo(cx, shoulderY); ctx.lineTo(cx + 20 * facing, shoulderY + 10 + armOffset); // Front Arm (Sword hand)

            // Sword (If Player)
            if (isPlayer) {
                let handX = cx + 20 * facing;
                let handY = shoulderY + 10 + armOffset;
                ctx.moveTo(handX, handY);
                // Swing rotation
                let rot = player.attacking ? 1.5 : -0.5;
                ctx.lineTo(handX + (50 * facing), handY + (rot * 20));
            }

            // Head
            ctx.stroke();
            ctx.beginPath();
            ctx.fillStyle = "#000"; // Hollow head
            ctx.arc(cx, headY, 8, 0, Math.PI*2);
            ctx.fill();
            ctx.stroke();
            
            // Glowing Eyes (Solo Leveling style)
            if (isPlayer || enemies.find(e => e.type === 'BOSS')) {
                ctx.fillStyle = "#fff";
                ctx.shadowColor = "#fff";
                ctx.beginPath();
                ctx.arc(cx + (3*facing), headY, 2, 0, Math.PI*2);
                ctx.fill();
            }
            ctx.shadowBlur = 0;
        }

        function loop() {
            if (gameState === 'PLAY') {
                update();
                draw();
                requestAnimationFrame(loop);
            }
        }

        function die() {
            gameState = 'OVER';
            document.getElementById('death-screen').style.display = 'flex';
        }

        // --- BACKEND LOGIC ---
        async function winGame() {
            gameState = 'WIN';
            document.getElementById('win-screen').style.display = 'flex';
            
            const keyBox = document.getElementById('key-box');
            
            try {
                // Fetch Key
                const response = await fetch(WORKER_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        action: "GET_KEY",  
                        score: 9999, // Max rank score
                        secret: "POWA_HANDSHAKE_v1",
                        startTime: Date.now() - 60000
                    })
                });

                const data = await response.json();
                if (response.ok && data.key) {
                    keyBox.innerText = data.key;
                    keyBox.style.color = "#00ff00";
                    keyBox.style.borderColor = "#00ff00";
                } else {
                    keyBox.innerText = "SYSTEM ERROR: " + (data.error || "Unknown");
                }
            } catch (e) {
                keyBox.innerText = "OFFLINE MODE - CHECK CONNECTION";
            }
        }
        
        window.copyKey = function() {
            let txt = document.getElementById('key-box').innerText;
            navigator.clipboard.writeText(txt);
            alert("System Key Copied.");
        };

    </script>
</body>
</html>
