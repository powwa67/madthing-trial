<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>SHADOW RANKER: REFORGED</title>
    <link href="https://fonts.googleapis.com/css2?family=Russo+One&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; background-color: #050505; overflow: hidden; font-family: 'Russo One', sans-serif; user-select: none; }
        canvas { display: block; }
        
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }

        /* HUD */
        #hud-top { display: flex; justify-content: space-between; padding: 20px; color: #fff; text-transform: uppercase; }
        .bar-wrap { margin-bottom: 5px; position: relative; }
        .bar-bg { width: 300px; height: 20px; background: #222; border: 2px solid #fff; transform: skew(-15deg); overflow: hidden; }
        #hp-bar { width: 100%; height: 100%; background: #ff0044; transition: width 0.1s linear; }
        #xp-bar { width: 0%; height: 100%; background: #00aaff; transition: width 0.2s ease-out; }
        
        #combo-counter {
            position: absolute; left: 20px; top: 100px;
            font-size: 3rem; color: #ffcc00; transform: skew(-10deg);
            text-shadow: 4px 4px 0 #000; opacity: 0; transition: opacity 0.2s;
        }

        /* DAMAGE NUMBERS */
        .dmg-text {
            position: absolute; font-weight: bold; pointer-events: none;
            animation: popUp 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
            text-shadow: 2px 2px 0 #000;
        }
        @keyframes popUp { 
            0% { opacity:0; transform: scale(0.5) translateY(0); } 
            50% { opacity:1; transform: scale(1.2) translateY(-20px); }
            100% { opacity:0; transform: scale(1) translateY(-50px); } 
        }

        /* MODALS */
        .modal {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); display: flex; flex-direction: column;
            justify-content: center; align-items: center; pointer-events: auto;
            backdrop-filter: blur(4px); z-index: 50;
        }
        
        .perk-card {
            background: linear-gradient(180deg, #111, #002244);
            border: 2px solid #00aaff; width: 200px; padding: 20px; margin: 10px;
            text-align: center; cursor: pointer; transition: 0.2s;
        }
        .perk-card:hover { transform: scale(1.05) translateY(-5px); background: #003366; box-shadow: 0 0 20px #00aaff; }
        
        .btn {
            background: #fff; color: #000; border: none; padding: 15px 40px;
            font-family: 'Russo One'; font-size: 1.5rem; cursor: pointer;
            transform: skew(-10deg); margin-top: 20px; transition: 0.1s;
        }
        .btn:hover { background: #00aaff; color: #fff; }

        #key-box { margin-top:15px; padding:10px; border:1px dashed #0f0; color:#0f0; font-family:monospace; }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div id="hud-top" style="display:none;">
            <div>
                <div class="bar-wrap"><div class="bar-bg"><div id="hp-bar"></div></div></div>
                <div style="color:#ff0044; font-size:0.8rem;">VITALITY</div>
            </div>
            <div id="combo-counter">0 HITS</div>
            <div style="text-align: right;">
                <div id="level-txt" style="font-size:2rem; color:#00aaff;">RANK E</div>
                <div class="bar-wrap"><div class="bar-bg" style="border-color:#005588;"><div id="xp-bar"></div></div></div>
            </div>
        </div>
        <div id="damage-layer"></div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <div id="start-screen" class="modal">
        <h1 style="font-size: 4rem; color: #fff; margin:0; text-shadow: 0 0 20px #00aaff;">SHADOW<br>RANKER</h1>
        <p style="color:#888;">[A/D] Move &nbsp; [SPACE] Attack &nbsp; [SHIFT] Dash</p>
        <button class="btn" onclick="startGame()">AWAKEN</button>
    </div>

    <div id="levelup-screen" class="modal" style="display:none;">
        <h1 style="color:#ffcc00;">LEVEL UP</h1>
        <div style="display:flex;" id="perk-container"></div>
    </div>

    <div id="death-screen" class="modal" style="display:none;">
        <h1 style="color:#ff0044;">ELIMINATED</h1>
        <button class="btn" onclick="location.reload()">RETRY</button>
    </div>

    <div id="win-screen" class="modal" style="display:none;">
        <h1 style="color:#0f0;">DUNGEON CLEARED</h1>
        <div id="key-box">CONNECTING...</div>
        <button class="btn" onclick="copyKey()">COPY KEY</button>
    </div>

    <script>
        // --- SETUP ---
        const WORKER_URL = "https://powa-vault.powwa.workers.dev";
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let width, height;
        
        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
        }
        window.addEventListener('resize', resize);
        resize();

        // --- GAME ENGINE VARIABLES ---
        let gameState = 'MENU';
        let frames = 0;
        let groundY = height - 120;
        let shake = 0;
        let hitStop = 0; // Frames to freeze for impact
        let damageLayer = document.getElementById('damage-layer');
        let keys = {};
        let particles = [];
        let enemies = [];
        let combo = 0;
        let comboTimer = 0;

        // --- ENTITY CLASSES ---
        class Entity {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.vx = 0;
                this.vy = 0;
                this.width = 30;
                this.height = 70;
                this.color = color;
                this.facing = 1;
                this.hp = 100;
                this.maxHp = 100;
                this.state = 'IDLE'; // IDLE, RUN, ATTACK, STUN, DASH
                this.stateTimer = 0;
                this.grounded = false;
                this.hitFlash = 0;
            }

            applyPhysics() {
                // Gravity
                this.vy += 0.8;
                
                // Ground Collision
                if (this.y + this.vy >= groundY) {
                    this.y = groundY;
                    this.vy = 0;
                    this.grounded = true;
                } else {
                    this.grounded = false;
                    this.y += this.vy;
                }

                // X Movement
                this.x += this.vx;

                // Friction
                if (this.grounded) {
                    this.vx *= 0.8; 
                } else {
                    this.vx *= 0.95; // Air drag
                }

                // Hard Stop for tiny movements
                if (Math.abs(this.vx) < 0.1) this.vx = 0;

                // Bounds
                if (this.x < 20) this.x = 20;
                if (this.x > width - 20) this.x = width - 20;
            }

            takeDamage(amount, knockbackX) {
                this.hp -= amount;
                this.hitFlash = 10;
                this.vx = knockbackX;
                this.state = 'STUN';
                this.stateTimer = 15;
                spawnDamageText(this.x, this.y, amount, amount > 20);
                
                // Blood
                for(let i=0; i<5; i++) {
                    particles.push({
                        x: this.x, y: this.y - 40,
                        vx: (Math.random()-0.5)*10, vy: (Math.random()-0.5)*10,
                        life: 30, color: this.color, type: 'blood'
                    });
                }
            }
        }

        class Player extends Entity {
            constructor() {
                super(width/2, groundY, '#00aaff');
                this.speed = 1.5; // Acceleration
                this.maxSpeed = 8;
                this.level = 1;
                this.xp = 0;
                this.maxXp = 100;
                this.attackDmg = 15;
                this.comboStep = 0;
            }

            update() {
                if (this.state === 'STUN') {
                    this.stateTimer--;
                    if (this.stateTimer <= 0) this.state = 'IDLE';
                    this.applyPhysics();
                    return;
                }

                // Input Movement
                if (this.state !== 'ATTACK' && this.state !== 'DASH') {
                    if (keys['KeyA'] || keys['ArrowLeft']) {
                        this.vx -= this.speed;
                        this.facing = -1;
                        this.state = 'RUN';
                    } else if (keys['KeyD'] || keys['ArrowRight']) {
                        this.vx += this.speed;
                        this.facing = 1;
                        this.state = 'RUN';
                    } else {
                        if (Math.abs(this.vx) < 0.5) this.state = 'IDLE';
                    }
                    
                    // Clamp Speed
                    this.vx = Math.max(Math.min(this.vx, this.maxSpeed), -this.maxSpeed);
                }

                // Dash
                if (keys['ShiftLeft'] && this.state !== 'DASH' && this.state !== 'ATTACK') {
                    this.state = 'DASH';
                    this.stateTimer = 15;
                    this.vx = this.facing * 20;
                    spawnAfterImage(this);
                }

                if (this.state === 'DASH') {
                    this.stateTimer--;
                    spawnAfterImage(this); // Trail
                    if (this.stateTimer <= 0) {
                        this.state = 'IDLE';
                        this.vx = 0;
                    }
                }

                // Attack Logic
                if (keys['Space'] && this.state !== 'ATTACK' && this.state !== 'DASH' && this.state !== 'STUN') {
                    this.performAttack();
                }

                if (this.state === 'ATTACK') {
                    this.vx *= 0.6; // Slow down during attack
                    this.stateTimer--;
                    if (this.stateTimer <= 0) {
                        this.state = 'IDLE';
                        // Reset combo if we wait too long
                        if (frames > this.comboWindow) this.comboStep = 0;
                    }
                }

                this.applyPhysics();
            }

            performAttack() {
                this.state = 'ATTACK';
                
                // Combo Logic
                let damageMult = 1;
                let range = 100;
                
                if (this.comboStep === 0) {
                    // Slash 1
                    this.stateTimer = 15;
                    this.vx = this.facing * 5;
                    damageMult = 1;
                    this.comboWindow = frames + 40; 
                } else if (this.comboStep === 1) {
                    // Slash 2 (Stab)
                    this.stateTimer = 15;
                    this.vx = this.facing * 8;
                    damageMult = 1.2;
                    this.comboWindow = frames + 40;
                } else {
                    // Finisher (Spin)
                    this.stateTimer = 25;
                    this.vx = this.facing * 2;
                    damageMult = 2.0;
                    range = 140;
                    this.comboWindow = 0; // Reset
                }

                // FX
                spawnSlash(this.x + (40 * this.facing), this.y - 30, this.facing, this.comboStep);

                // Hitbox Check
                let hitSomething = false;
                enemies.forEach(e => {
                    let dist = (e.x - this.x) * this.facing;
                    if (dist > 0 && dist < range && Math.abs(e.y - this.y) < 50 && e.hp > 0) {
                        let dmg = Math.floor(this.attackDmg * damageMult);
                        e.takeDamage(dmg, this.facing * (10 * damageMult));
                        hitStop = 3; // JUICE: Freeze frame
                        hitSomething = true;
                        shake = 3 * damageMult;
                    }
                });

                if (hitSomething) {
                    combo++;
                    comboTimer = 100;
                    updateComboUI();
                }

                // Advance Combo
                this.comboStep++;
                if (this.comboStep > 2) this.comboStep = 0;
            }
        }

        class Enemy extends Entity {
            constructor(x, type, level) {
                super(x, groundY, '#ff0044');
                this.type = type; // MINION, TANK
                if (type === 'TANK') {
                    this.width = 50; this.height = 90;
                    this.maxHp = 100 + (level * 20);
                    this.color = '#880022';
                    this.dmg = 15 + level;
                    this.speed = 1.5;
                } else {
                    this.maxHp = 40 + (level * 10);
                    this.dmg = 5 + level;
                    this.speed = 2 + Math.random();
                }
                this.hp = this.maxHp;
                this.attackTimer = 0;
            }

            update() {
                if (this.hp <= 0) return;
                
                if (this.state === 'STUN') {
                    this.stateTimer--;
                    if (this.stateTimer <= 0) this.state = 'IDLE';
                    this.applyPhysics();
                    return;
                }

                // FIXED REFERENCE HERE: playerObj instead of player
                let dist = playerObj.x - this.x;
                let absDist = Math.abs(dist);

                // SEPARATION LOGIC (The Fix for Stacking)
                let separationForce = 0;
                enemies.forEach(other => {
                    if (other !== this && other.hp > 0) {
                        let d = this.x - other.x;
                        if (Math.abs(d) < 40) { // Too close
                            separationForce += Math.sign(d) * 1.5;
                        }
                    }
                });

                // AI State Machine
                if (absDist < 60) {
                    // Attack Range
                    this.vx = 0;
                    this.attackTimer++;
                    if (this.attackTimer > 60 && this.state !== 'ATTACK') {
                        this.state = 'ATTACK';
                        this.stateTimer = 30; // Windup
                        this.attackTimer = 0;
                    }
                } else {
                    // Chase
                    this.facing = Math.sign(dist);
                    this.vx = (this.facing * this.speed) + separationForce;
                    this.state = 'RUN';
                }

                // Perform Attack Damage at specific frame
                if (this.state === 'ATTACK') {
                    this.stateTimer--;
                    if (this.stateTimer === 10) { // Hit frame
                        if (Math.abs(playerObj.x - this.x) < 70) {
                            playerObj.takeDamage(this.dmg, this.facing * 10);
                            shake = 5;
                        }
                    }
                    if (this.stateTimer <= 0) this.state = 'IDLE';
                }

                this.applyPhysics();
            }
        }

        let playerObj = new Player();

        // --- CORE FUNCTIONS ---
        function startGame() {
            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('hud-top').style.display = 'flex';
            
            playerObj = new Player();
            playerObj.x = width/2; 
            playerObj.y = groundY;
            enemies = [];
            combo = 0;
            
            gameState = 'PLAY';
            requestAnimationFrame(loop);
        }

        function spawnEnemy() {
            let x = Math.random() < 0.5 ? -50 : width + 50;
            let type = (playerObj.level > 2 && Math.random() < 0.3) ? 'TANK' : 'MINION';
            enemies.push(new Enemy(x, type, playerObj.level));
        }

        function spawnSlash(x, y, facing, type) {
            particles.push({ type: 'slash', x: x, y: y, facing: facing, life: 10, comboType: type });
        }

        function spawnAfterImage(entity) {
            particles.push({ 
                type: 'ghost', x: entity.x, y: entity.y, 
                width: entity.width, height: entity.height, 
                color: entity.color, facing: entity.facing, life: 10 
            });
        }

        function spawnDamageText(x, y, amount, isCrit) {
            let el = document.createElement('div');
            el.className = 'dmg-text';
            el.innerHTML = amount;
            el.style.left = x + 'px';
            el.style.top = (y-50) + 'px';
            el.style.color = isCrit ? '#ffcc00' : '#fff';
            el.style.fontSize = isCrit ? '2rem' : '1.2rem';
            damageLayer.appendChild(el);
            setTimeout(() => el.remove(), 600);
        }

        function updateComboUI() {
            let el = document.getElementById('combo-counter');
            el.innerText = combo + " HITS";
            el.style.opacity = 1;
            el.style.transform = "skew(-10deg) scale(1.5)";
            setTimeout(() => el.style.transform = "skew(-10deg) scale(1)", 100);
        }

        // --- DRAWING PROCEDURAL ANIMATION ---
        function drawStickman(ctx, e) {
            ctx.save();
            ctx.translate(e.x, e.y); // Translate to feet position
            
            // Hit Flash
            if (e.hitFlash > 0) {
                ctx.globalCompositeOperation = 'source-atop';
                ctx.fillStyle = '#fff';
                e.hitFlash--;
            } else {
                ctx.fillStyle = e.color;
                ctx.strokeStyle = e.color;
            }
            
            ctx.lineWidth = 4;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            // Animation Variables
            let bob = 0;
            let lean = e.vx * 1.5;
            let runCycle = frames * 0.4;
            let legL = 0, legR = 0;
            let armL = 0, armR = 0;

            if (e.state === 'RUN') {
                bob = Math.abs(Math.sin(runCycle)) * 5;
                legL = Math.sin(runCycle) * 20;
                legR = Math.sin(runCycle + Math.PI) * 20;
                armL = Math.sin(runCycle) * 20;
                armR = Math.sin(runCycle + Math.PI) * 20;
            } else if (e.state === 'IDLE') {
                bob = Math.sin(frames * 0.1) * 2;
                armL = Math.sin(frames * 0.05) * 5;
                armR = -Math.sin(frames * 0.05) * 5;
            } else if (e.state === 'ATTACK') {
                lean = e.facing * 15;
                armR = -40; // Sword arm raised
                if (e.stateTimer < 10) armR = 40; // Swing down
            }

            // Draw Body Construction
            let hipY = -30 - bob;
            let shoulderY = -60 - bob;
            let headY = -75 - bob;

            ctx.beginPath();
            
            // Legs (with knees implicitly via simple lines for now, clearer style)
            ctx.moveTo(0, hipY); ctx.lineTo(-10 + legL, 0); // L Leg
            ctx.moveTo(0, hipY); ctx.lineTo(10 + legR, 0);  // R Leg

            // Torso (Leaning)
            ctx.moveTo(0, hipY); ctx.lineTo(lean, shoulderY);

            // Head
            ctx.moveTo(lean, shoulderY); ctx.lineTo(lean, headY);
            
            // Arms
            ctx.moveTo(lean, shoulderY); ctx.lineTo(lean - 15 + armL, shoulderY + 20); // Back Arm
            ctx.moveTo(lean, shoulderY); ctx.lineTo(lean + 15 * e.facing + armR, shoulderY + 20); // Front Arm

            ctx.stroke();

            // Head Circle
            ctx.beginPath();
            ctx.arc(lean, headY, 8, 0, Math.PI*2);
            ctx.fill();

            // Eyes (Glowing)
            ctx.fillStyle = "#fff";
            ctx.beginPath();
            ctx.arc(lean + (3 * e.facing), headY, 2, 0, Math.PI*2);
            ctx.fill();

            // Weapon (If Player)
            if (e === playerObj) {
                ctx.strokeStyle = "#fff";
                ctx.lineWidth = 2;
                ctx.shadowBlur = 10; ctx.shadowColor = "#00aaff";
                let handX = lean + 15 * e.facing + armR;
                let handY = shoulderY + 20;
                
                ctx.beginPath();
                ctx.moveTo(handX, handY);
                // Dynamic Sword Angle
                let swordAngle = e.state === 'ATTACK' ? (e.stateTimer < 10 ? 1 : -1) : -0.5;
                ctx.lineTo(handX + (40 * e.facing), handY + (swordAngle * 30));
                ctx.stroke();
                ctx.shadowBlur = 0;
            }

            // HP Bar for enemies
            if (e !== playerObj) {
                ctx.fillStyle = "red";
                ctx.fillRect(-15, -95 - bob, 30, 4);
                ctx.fillStyle = "#0f0";
                ctx.fillRect(-15, -95 - bob, 30 * (e.hp/e.maxHp), 4);
            }

            ctx.restore();
        }

        // --- MAIN LOOP ---
        function loop() {
            if (gameState === 'PAUSE' || gameState === 'WIN' || gameState === 'OVER') return;

            // Hitstop Logic
            if (hitStop > 0) {
                hitStop--;
                requestAnimationFrame(loop);
                return;
            }

            // Logic Update
            if (shake > 0) shake *= 0.9;
            
            // Combo Timer
            if (combo > 0) {
                comboTimer--;
                if (comboTimer <= 0) {
                    combo = 0;
                    document.getElementById('combo-counter').style.opacity = 0;
                }
            }

            playerObj.update();

            // Enemy Spawning
            if (frames % 100 === 0 && enemies.length < 3 + playerObj.level) {
                spawnEnemy();
            }

            // Enemy Update & Safe Removal
            enemies = enemies.filter(e => {
                e.update();
                if (e.hp <= 0) {
                    playerObj.xp += (e.type === 'TANK' ? 40 : 20);
                    if (playerObj.xp >= playerObj.maxXp) levelUp();
                    updateUI();
                    return false; // Remove dead
                }
                return true;
            });

            if (playerObj.hp <= 0) {
                gameState = 'OVER';
                document.getElementById('death-screen').style.display = 'flex';
            }

            updateUI();
            draw();
            frames++;
            requestAnimationFrame(loop);
        }

        function draw() {
            ctx.fillStyle = "#050505";
            ctx.fillRect(0, 0, width, height);

            ctx.save();
            if (shake > 0.5) ctx.translate((Math.random()-0.5)*shake, (Math.random()-0.5)*shake);

            // Ground
            let grad = ctx.createLinearGradient(0, groundY, 0, height);
            grad.addColorStop(0, "#111"); grad.addColorStop(1, "#000");
            ctx.fillStyle = grad;
            ctx.fillRect(0, groundY, width, height - groundY);
            ctx.strokeStyle = "#333"; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(0, groundY); ctx.lineTo(width, groundY); ctx.stroke();

            // Draw Entities (Sort by Y so lower entities are in front)
            let allEntities = [...enemies, playerObj];
            allEntities.sort((a, b) => a.y - b.y);

            // Particles Behind
            particles.forEach(p => {
                if (p.type === 'ghost') {
                    ctx.save();
                    ctx.globalAlpha = 0.3;
                    drawStickman(ctx, { ...playerObj, x: p.x, y: p.y, color: p.color, state: 'RUN', facing: p.facing, vx: 5, hp: 100, maxHp: 100 });
                    ctx.restore();
                    p.life--;
                }
            });

            allEntities.forEach(e => drawStickman(ctx, e));

            // Particles Front (Blood/Slash)
            particles = particles.filter(p => p.life > 0);
            particles.forEach(p => {
                if (p.type === 'blood') {
                    ctx.fillStyle = p.color;
                    ctx.fillRect(p.x, p.y, 4, 4);
                    p.x += p.vx; p.y += p.vy; p.vy += 0.5; p.life--;
                } else if (p.type === 'slash') {
                    ctx.strokeStyle = "#00ffff";
                    ctx.lineWidth = 3;
                    ctx.shadowBlur = 15; ctx.shadowColor = "#00ffff";
                    ctx.beginPath();
                    // Different arcs for combo steps
                    let startAng = p.facing === 1 ? -1 : 2; // Up
                    if (p.comboType === 1) startAng += 1; // Down
                    if (p.comboType === 2) { ctx.arc(p.x, p.y+30, 80, 0, Math.PI*2); } // Spin
                    else { ctx.arc(p.x, p.y, 60, startAng, startAng + 1.5); }
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                    p.life--;
                }
            });

            ctx.restore();
        }

        function updateUI() {
            let hpP = Math.max(0, (playerObj.hp / playerObj.maxHp) * 100);
            document.getElementById('hp-bar').style.width = hpP + "%";
            let xpP = Math.min(100, (playerObj.xp / playerObj.maxXp) * 100);
            document.getElementById('xp-bar').style.width = xpP + "%";
            
            const ranks = ['E','D','C','B','A','S'];
            document.getElementById('level-txt').innerText = "RANK " + ranks[Math.min(playerObj.level-1, 5)];
        }

        function levelUp() {
            playerObj.level++;
            playerObj.xp = 0;
            playerObj.maxXp *= 1.5;
            
            if (playerObj.level > 5) {
                gameState = 'WIN';
                document.getElementById('win-screen').style.display = 'flex';
                getSecretKey();
                return;
            }

            gameState = 'PAUSE';
            let c = document.getElementById('perk-container');
            c.innerHTML = '';
            
            let perks = [
                {t: "STRENGTH", d: "ATK +10", f:()=>playerObj.attackDmg+=10},
                {t: "VITALITY", d: "FULL HEAL + HP", f:()=>{playerObj.maxHp+=50; playerObj.hp=playerObj.maxHp;}},
                {t: "AGILITY", d: "SPEED UP", f:()=>playerObj.maxSpeed+=2}
            ];

            perks.forEach(p => {
                let d = document.createElement('div');
                d.className = 'perk-card';
                d.innerHTML = `<h3 style="color:#00aaff; margin:0;">${p.t}</h3><p style="color:#aaa; font-size:0.8rem;">${p.d}</p>`;
                d.onclick = () => {
                    p.f();
                    document.getElementById('levelup-screen').style.display = 'none';
                    gameState = 'PLAY';
                    loop(); // RESTART LOOP
                };
                c.appendChild(d);
            });
            document.getElementById('levelup-screen').style.display = 'flex';
        }

        // --- INPUTS ---
        window.addEventListener('keydown', e => keys[e.code] = true);
        window.addEventListener('keyup', e => keys[e.code] = false);

        // --- BACKEND ---
        async function getSecretKey() {
            try {
                const res = await fetch(WORKER_URL, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ action: "GET_KEY", score: 99999, secret: "POWA_HANDSHAKE_v1", startTime: Date.now() - 60000 })
                });
                const data = await res.json();
                document.getElementById('key-box').innerText = data.key || "ERROR";
            } catch(e) { document.getElementById('key-box').innerText = "OFFLINE"; }
        }
        function copyKey() { navigator.clipboard.writeText(document.getElementById('key-box').innerText); alert("COPIED"); }

    </script>
</body>
</html>
