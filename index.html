<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>SHADOW RANKER: REFORGED</title>
    <link href="https://fonts.googleapis.com/css2?family=Russo+One&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; background-color: #050505; overflow: hidden; font-family: 'Russo One', sans-serif; user-select: none; }
        canvas { display: block; }
        
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }

        #hud-top { display: flex; justify-content: space-between; padding: 20px; color: #fff; text-transform: uppercase; }
        .bar-wrap { margin-bottom: 5px; position: relative; }
        .bar-bg { width: 300px; height: 20px; background: #222; border: 2px solid #fff; transform: skew(-15deg); overflow: hidden; position: relative; }
        #hp-bar { width: 100%; height: 100%; background: linear-gradient(90deg, #ff0044, #ff3366); transition: width 0.1s linear; box-shadow: 0 0 10px #ff0044; }
        #hp-bar-delay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #fff; transition: width 0.5s ease-out; opacity: 0.3; }
        #xp-bar { width: 0%; height: 100%; background: linear-gradient(90deg, #0066ff, #00aaff); transition: width 0.2s ease-out; box-shadow: 0 0 10px #00aaff; }
        
        #combo-counter {
            position: absolute; left: 20px; top: 100px;
            font-size: 3rem; color: #ffcc00; transform: skew(-10deg);
            text-shadow: 4px 4px 0#000, 0 0 20px #ff6600; opacity: 0; transition: opacity 0.2s;
        }
        
        #kill-counter {
            position: absolute; right: 20px; top: 100px;
            font-size: 1.5rem; color: #ff0044;
            text-shadow: 2px 2px 0 #000;}

        .dmg-text {
            position: absolute; font-weight: bold; pointer-events: none;
            animation: popUp 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
            text-shadow: 2px 2px 0 #000, 0 0 10px currentColor;
        }
        @keyframes popUp {
            0% { opacity:0; transform: scale(0.5) translateY(0) rotate(-10deg); } 
            30% { opacity:1; transform: scale(1.3) translateY(-30px) rotate(5deg); }
            100% { opacity:0; transform: scale(0.8) translateY(-80px) rotate(-5deg); } 
        }

        .modal {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); display: flex; flex-direction: column;
            justify-content: center; align-items: center; pointer-events: auto;
            backdrop-filter: blur(8px); z-index: 50;
        }
        
        .perk-card {
            background: linear-gradient(180deg, #111, #002244);
            border: 2px solid #00aaff; width: 200px; padding: 20px; margin: 10px;
            text-align: center; cursor: pointer; transition: 0.3s;
            position: relative; overflow: hidden;
        }
        .perk-card::before {
            content: ''; position: absolute; top: -50%; left: -50%;
            width: 200%; height: 200%; background: linear-gradient(45deg, transparent, rgba(0,170,255,0.1), transparent);
            transform: rotate(45deg); transition: 0.5s;
        }
        .perk-card:hover::before { left: 100%; }
        .perk-card:hover { transform: scale(1.08) translateY(-8px); background: #003366; box-shadow: 0 0 30px #00aaff, 0 10px 40px rgba(0,0,0,0.5); }
        
        .btn {
            background: linear-gradient(180deg, #fff, #ccc); color: #000; border: none; padding: 15px 40px;
            font-family: 'Russo One'; font-size: 1.5rem; cursor: pointer;
            transform: skew(-10deg); margin-top: 20px; transition: 0.2s;
            box-shadow: 0 5px 20px rgba(0,0,0,0.5);
        }
        .btn:hover { background: linear-gradient(180deg, #00ddff, #0088cc); color: #fff; transform: skew(-10deg) scale(1.05); }

        #key-box { margin-top:15px; padding:10px; border:1px dashed #0f0; color:#0f0; font-family:monospace; }
        .screen-flash {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; opacity: 0; z-index: 100;
        }
    </style>
</head>
<body>

    <div id="screen-flash" class="screen-flash"></div>

    <div id="ui-layer">
        <div id="hud-top" style="display:none;">
            <div>
                <div class="bar-wrap">
                    <div class="bar-bg">
                        <div id="hp-bar-delay"></div>
                        <div id="hp-bar"></div>
                    </div>
                </div>
                <div style="color:#ff0044; font-size:0.8rem;">VITALITY</div></div>
            <div id="combo-counter">0HITS</div>
            <div id="kill-counter">KILLS: 0</div><div style="text-align: right;">
                <div id="level-txt" style="font-size:2rem; color:#00aaff; text-shadow: 0 0 20px #00aaff;">RANK E</div>
                <div class="bar-wrap"><div class="bar-bg" style="border-color:#005588;"><div id="xp-bar"></div></div></div>
            </div>
        </div>
        <div id="damage-layer"></div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <div id="start-screen" class="modal">
        <h1style="font-size: 4rem; color: #fff; margin:0; text-shadow: 0 0 30px #00aaff, 0 0 60px #0066ff;">SHADOW<br>RANKER</h1>
        <p style="color:#888; text-shadow: 0 0 10px #444;">[A/D] Move &nbsp; [SPACE] Attack &nbsp; [SHIFT] Dash &nbsp; [W] Jump</p>
        <button class="btn" onclick="startGame()">AWAKEN</button>
    </div>

    <div id="levelup-screen" class="modal" style="display:none;">
        <h1 style="color:#ffcc00; text-shadow: 0 0 30px #ff6600;">LEVEL UP</h1>
        <div style="display:flex;" id="perk-container"></div>
    </div>

    <div id="death-screen" class="modal" style="display:none;">
        <h1 style="color:#ff0044; text-shadow: 0 0 30px #ff0044;">ELIMINATED</h1>
        <p style="color:#666;">Kills: <span id="final-kills">0</span></p>
        <button class="btn" onclick="location.reload()">RETRY</button>
    </div>

    <div id="win-screen" class="modal" style="display:none;">
        <h1 style="color:#0f0; text-shadow: 0 0 30px #0f0;">DUNGEON CLEARED</h1>
        <div id="key-box">CONNECTING...</div>
        <button class="btn" onclick="copyKey()">COPY KEY</button>
    </div>

    <script>
        const WORKER_URL = "https://powa-vault.powwa.workers.dev";
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let width, height;
        
        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;}
        window.addEventListener('resize', resize);
        resize();

        // Game State
        let gameState = 'MENU';
        let frames = 0;
        let groundY = height - 120;
        let shake = 0;
        let shakeDecay = 0.9;
        let hitStop = 0;
        let slowMotion = 1;
        let slowMotionTimer = 0;
        let damageLayer = document.getElementById('damage-layer');
        let keys = {};
        let particles = [];
        let enemies = [];
        let combo = 0;
        let comboTimer = 0;
        let killCount = 0;
        let cameraX = 0;
        let cameraTargetX = 0;
        
        // Ambient particles
        let ambientParticles = [];
        for (let i = 0; i < 50; i++) {
            ambientParticles.push({
                x: Math.random() * width,
                y: Math.random() * height,
                size: Math.random() * 2 + 0.5,
                speed: Math.random() * 0.5 + 0.2,
                opacity: Math.random() * 0.5
            });
        }

        // Easing functions
        const ease = {
            out: t => 1 - Math.pow(1 - t, 3),
            in: t => t * t * t,
            inOut: t => t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2,
            elastic: t => t === 0 ? 0 : t === 1 ? 1 : Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * (2 * Math.PI) / 3) + 1,
            bounce: t => {
                const n1 = 7.5625,d1 = 2.75;
                if (t < 1 / d1) return n1 * t * t;
                else if (t < 2 / d1) return n1 * (t -= 1.5 / d1) * t + 0.75;
                else if (t < 2.5 / d1) return n1 * (t -= 2.25 / d1) * t + 0.9375;
                else return n1 * (t -= 2.625 / d1) * t + 0.984375;
            }
        };

        // Screen flash effect
        function screenFlash(color, duration = 100) {
            const flash = document.getElementById('screen-flash');
            flash.style.background = color;
            flash.style.opacity = '0.3';
            setTimeout(() => flash.style.opacity = '0', duration);
        }

        class Entity {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.vx = 0;
                this.vy = 0;
                this.width = 30;
                this.height = 70;
                this.color = color;
                this.facing = 1;
                this.hp = 100;
                this.maxHp = 100;
                this.state = 'IDLE';
                this.stateTimer = 0;
                this.grounded = false;
                this.hitFlash = 0;
                this.squash = 1;
                this.stretch = 1;
                this.rotation = 0;
                this.targetRotation = 0;
                this.breathe = 0;
                this.landingSquash = 0;
                this.wasGrounded = false;
                this.trailPositions = [];
                this.attackCharge = 0;
                this.auraIntensity = 0;
            }

            applyPhysics() {
                this.vy += 0.6* slowMotion;
                // Landing detection
                this.wasGrounded = this.grounded;
                
                if (this.y + this.vy >= groundY) {
                    this.y = groundY;
                    // Landing impact
                    if (!this.wasGrounded && Math.abs(this.vy) > 5) {
                        this.landingSquash = Math.min(0.3, Math.abs(this.vy) * 0.02);
                        shake += Math.abs(this.vy) * 0.2;
                        
                        // Dust particles
                        for (let i = 0; i < 8; i++) {
                            particles.push({
                                type: 'dust',
                                x: this.x + (Math.random() - 0.5) * 30,
                                y: groundY,
                                vx: (Math.random() - 0.5) * 4,
                                vy: -Math.random() * 3,
                                life: 30 + Math.random() * 20,
                                size: 3 + Math.random() * 4,
                                opacity: 0.6
                            });
                        }
                    }
                    
                    this.vy = 0;
                    this.grounded = true;
                } else {
                    this.grounded = false;
                    this.y += this.vy * slowMotion;
                }

                this.x += this.vx * slowMotion;

                if (this.grounded) {
                    this.vx *= 0.85;
                } else {
                    this.vx *= 0.98;
                }

                if (Math.abs(this.vx) < 0.1) this.vx = 0;

                if (this.x < 50) this.x = 50;
                if (this.x > width - 50) this.x = width - 50;

                // Squash/stretch recovery
                this.landingSquash *= 0.85;
                this.squash += (1 - this.squash) * 0.2;
                this.stretch += (1 - this.stretch) * 0.2;
                
                // Rotation recovery
                this.rotation += (this.targetRotation - this.rotation) * 0.15;
                this.targetRotation *= 0.9;
                
                // Breathe animation
                this.breathe = Math.sin(frames * 0.05) * 0.02;
                
                // Trail positions
                this.trailPositions.unshift({ x: this.x, y: this.y });
                if (this.trailPositions.length > 10) this.trailPositions.pop();
            }

            takeDamage(amount, knockbackX, knockbackY = -5) {
                this.hp -= amount;
                this.hitFlash = 12;
                this.vx = knockbackX;
                this.vy = knockbackY;
                this.state = 'STUN';
                this.stateTimer = 20;
                this.squash = 0.7;
                this.stretch = 1.3;
                this.targetRotation = Math.sign(knockbackX) * 0.3;
                
                spawnDamageText(this.x, this.y - 50, amount, amount > 20);
                // Blood particles with physics
                for (let i = 0; i < 8; i++) {
                    particles.push({
                        x: this.x,
                        y: this.y - 40,
                        vx: knockbackX * 0.5 + (Math.random() - 0.5) * 12,
                        vy: (Math.random() - 0.5) * 10- 3,
                        life: 40 + Math.random() * 20,
                        color: this.color,
                        type: 'blood',
                        size: 2 + Math.random() * 4,
                        gravity: 0.3
                    });
                }
                
                // Impact spark
                particles.push({
                    type: 'impact',
                    x: this.x + knockbackX * 2,
                    y: this.y - 40,
                    life: 15,
                    size: 30 + amount
                });
            }
        }

        class Player extends Entity {
            constructor() {
                super(width / 2, groundY, '#00aaff');
                this.speed = 1.2;
                this.maxSpeed = 7;
                this.level = 1;
                this.xp = 0;
                this.maxXp = 100;
                this.attackDmg = 15;
                this.comboStep = 0;
                this.dashCooldown = 0;
                this.jumpCount = 0;
                this.maxJumps = 2;
                this.capePoints = [];
                this.hairPoints = [];
                
                // Initialize cape physics
                for (let i = 0; i < 6; i++) {
                    this.capePoints.push({ x: 0, y: 0, vx: 0, vy: 0 });
                }
                // Initialize hair physics
                for (let i = 0; i < 4; i++) {
                    this.hairPoints.push({ x: 0, y: 0, vx: 0, vy: 0 });
                }
            }

            update() {
                this.dashCooldown = Math.max(0, this.dashCooldown - 1);
                
                // Aura based on combo
                this.auraIntensity = Math.min(1, combo * 0.1);
                
                if (this.state === 'STUN') {
                    this.stateTimer--;
                    if (this.stateTimer <= 0) this.state = 'IDLE';
                this.applyPhysics();
                    this.updatePhysicsElements();
                    return;
                }

                // Movement
                if (this.state !== 'ATTACK' && this.state !== 'DASH') {
                    let moveDir = 0;
                    if (keys['KeyA'] || keys['ArrowLeft']) moveDir = -1;
                    else if (keys['KeyD'] || keys['ArrowRight']) moveDir = 1;    if (moveDir !== 0) {
                        this.vx += moveDir * this.speed;
                        this.facing = moveDir;
                        this.state = 'RUN';
                        
                        // Running dust
                        if (this.grounded && frames % 8 === 0) {
                            particles.push({
                                type: 'dust',
                                x: this.x - this.facing * 10,
                                y: groundY,
                                vx: -this.facing * 2,
                                vy: -Math.random() * 2,
                                life: 20,
                                size: 3,
                                opacity: 0.4
                            });
                        }
                    } else {
                        if (Math.abs(this.vx) < 0.5) this.state = 'IDLE';
                    }
                    
                    this.vx = Math.max(Math.min(this.vx, this.maxSpeed), -this.maxSpeed);
                }

                // Jump
                if ((keys['KeyW'] || keys['ArrowUp'] || keys['Space']) && this.state !== 'ATTACK' && this.state !== 'DASH') {
                    if (this.grounded) {
                        this.vy = -14;
                        this.jumpCount = 1;
                        this.grounded = false;
                        this.squash = 1.3;
                        this.stretch = 0.7;
                        spawnJumpEffect(this.x, groundY);
                    } else if (this.jumpCount < this.maxJumps && !keys['jumpHeld']) {
                        this.vy = -12;
                        this.jumpCount++;
                        spawnJumpEffect(this.x, this.y);
                    }keys['jumpHeld'] = true;
                }
                if (!keys['KeyW'] && !keys['ArrowUp'] && !keys['Space']) {
                    keys['jumpHeld'] = false;
                }
                
                if (this.grounded) this.jumpCount = 0;

                // Dash
                if (keys['ShiftLeft'] && this.state !== 'DASH' && this.state !== 'ATTACK' && this.dashCooldown <= 0) {
                    this.state = 'DASH';
                    this.stateTimer = 12;
                    this.vx = this.facing * 25;
                    this.dashCooldown = 40;
                    this.squash = 0.5;
                    this.stretch = 1.5;
                    screenFlash('#00aaff', 50);
                    
                    // Dash particles
                    for (let i = 0; i < 10; i++) {
                        particles.push({
                            type: 'dash',
                            x: this.x,
                            y: this.y - 35,
                            vx: -this.facing * (5 + Math.random() * 5),
                            vy: (Math.random() - 0.5) * 3,
                            life: 20,
                            size: 5 + Math.random() * 5
                        });
                    }
                }

                if (this.state === 'DASH') {
                    this.stateTimer--;
                    spawnAfterImage(this);
                    if (this.stateTimer <= 0) {
                        this.state = 'IDLE';
                        this.vx *= 0.3;
                    }
                }

                // Attack
                if (keys['KeyJ'] && this.state !== 'ATTACK' && this.state !== 'DASH' && this.state !== 'STUN') {
                    this.performAttack();
                }

                if (this.state === 'ATTACK') {
                    this.vx *= 0.7;
                    this.stateTimer--;
                    if (this.stateTimer <= 0) {
                        this.state = 'IDLE';
                        if (frames > this.comboWindow) this.comboStep =0;
                    }
                }

                this.applyPhysics();
                this.updatePhysicsElements();
            }

            updatePhysicsElements() {
                // Cape physics
                let capeAnchorX = this.x - this.facing * 8;
                let capeAnchorY = this.y - 55;
                
                for (let i = 0; i < this.capePoints.length; i++) {
                    let p = this.capePoints[i];
                    let targetX = i === 0 ? capeAnchorX : this.capePoints[i - 1].x;
                    let targetY = i === 0 ? capeAnchorY : this.capePoints[i - 1].y + 8;
                    
                    p.vx += (targetX - p.x) * 0.3;
                    p.vy += (targetY - p.y) * 0.2;
                    p.vx -= this.vx * 0.15;
                    p.vy +=0.2;
                    p.vx *= 0.85;
                    p.vy *= 0.85;p.x += p.vx;
                    p.y += p.vy;
                }
                
                // Hair physics
                let hairAnchorX = this.x;
                let hairAnchorY = this.y - 78;
                
                for (let i = 0; i < this.hairPoints.length; i++) {
                    let p = this.hairPoints[i];
                    let targetX = i === 0 ? hairAnchorX : this.hairPoints[i - 1].x - this.facing * 4;
                    let targetY = i === 0 ? hairAnchorY : this.hairPoints[i - 1].y - 3;
                    
                    p.vx += (targetX - p.x) * 0.4;
                    p.vy += (targetY - p.y) * 0.3;
                    p.vx -= this.vx * 0.1;
                    p.vx *= 0.8;
                    p.vy *= 0.8;
                    p.x += p.vx;
                    p.y += p.vy;
                }
            }

            performAttack() {
                this.state = 'ATTACK';
                keys['KeyJ'] = false;
                
                let damageMult = 1;
                let range = 90;
                let knockbackMult = 1;

                if (this.comboStep === 0) {
                    this.stateTimer = 12;
                    this.vx = this.facing * 6;
                    damageMult = 1;
                    this.comboWindow = frames + 35;
                } else if (this.comboStep === 1) {
                    this.stateTimer = 12;
                    this.vx = this.facing * 8;
                    damageMult = 1.3;
                    this.comboWindow = frames + 35;
                } else if (this.comboStep === 2) {
                    this.stateTimer = 18;
                    this.vx = this.facing * 4;
                    damageMult = 1.5;
                    knockbackMult = 1.5;
                    this.comboWindow = frames + 40;
                } else {
                    this.stateTimer = 25;
                    this.vx = this.facing * 3;
                    damageMult = 2.5;
                    range = 130;
                    knockbackMult = 2;
                    this.comboWindow = 0;
                    slowMotion = 0.3;
                    slowMotionTimer = 15;
                }

                this.squash = 0.8;
                this.stretch = 1.2;
                
                spawnSlash(this.x + (50 * this.facing), this.y - 35, this.facing, this.comboStep);

                let hitSomething = false;
                enemies.forEach(e => {
                    let dist = (e.x - this.x) * this.facing;
                    if (dist > -20 && dist < range && Math.abs(e.y - this.y) < 60&& e.hp > 0) {
                        let dmg = Math.floor(this.attackDmg * damageMult * (1 + combo * 0.05));
                        e.takeDamage(dmg, this.facing * (12 * knockbackMult), -8* knockbackMult);
                        hitStop = 4+ Math.floor(damageMult);
                        hitSomething = true;shake = 4* damageMult;
                        if (this.comboStep >= 3) {
                            screenFlash('#ffffff', 80);
                        }
                    }
                });

                if (hitSomething) {
                    combo++;
                    comboTimer = 120;
                    updateComboUI();
                }

                this.comboStep++;
                if (this.comboStep > 3) this.comboStep = 0;
            }
        }

        class Enemy extends Entity {
            constructor(x, type, level) {
                super(x, groundY, '#ff0044');
                this.type = type;
                this.level = level;
                if (type === 'TANK') {
                    this.width = 45;
                    this.height = 85;
                    this.maxHp = 120+ (level * 25);
                    this.color = '#aa0022';
                    this.dmg = 18+ level * 2;
                    this.speed = 1.2;
                } else if (type === 'FAST') {
                    this.width = 25;
                    this.height = 60;
                    this.maxHp = 30 + (level * 8);
                    this.color = '#ff6600';
                    this.dmg = 8 + level;
                    this.speed = 3.5;
                } else {
                    this.maxHp = 50 + (level * 12);
                    this.dmg = 10 + level;
                    this.speed = 1.8+ Math.random() * 0
