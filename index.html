<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>PROTOCOL: BLACKOUT</title>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>

    <style>
        :root {
            --term-green: #33ff00;
            --term-red: #ff0000;
            --term-dim: #1a331a;
        }

        body {
            margin: 0;
            background-color: #050505;
            font-family: 'VT323', monospace;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            user-select: none;
            cursor: none; /* Hide cursor for immersion */
        }

        /* --- CRT / VHS EFFECTS --- */
        #crt-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), 
                        linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 2px, 3px 100%;
            pointer-events: none; z-index: 50;
        }

        #vignette {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, rgba(0,0,0,0) 50%, rgba(0,0,0,1) 95%);
            pointer-events: none; z-index: 40;
        }

        #scanline {
            width: 100%; height: 100px; z-index: 51;
            background: linear-gradient(0deg, rgba(0,0,0,0) 0%, rgba(33, 255, 33, 0.04) 50%, rgba(0,0,0,0) 100%);
            opacity: 0.1; position: absolute; bottom: 100%; pointer-events: none;
            animation: scanline 10s linear infinite;
        }
        @keyframes scanline { 0% { bottom: 100%; } 100% { bottom: -100%; } }

        /* --- GAME CONTAINER --- */
        #game-container {
            position: relative; width: 100%; height: 100%;
            background: #000; overflow: hidden;
        }

        canvas { display: block; width: 100%; height: 100%; image-rendering: pixelated; }

        /* --- UI ELEMENTS --- */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; padding: 20px; box-sizing: border-box;
            display: flex; flex-direction: column; justify-content: space-between;
            z-index: 60;
        }

        .hud-text {
            color: var(--term-green); font-size: 1.5rem; text-shadow: 0 0 5px var(--term-green);
            letter-spacing: 2px;
        }

        #noise-meter-box {
            border: 1px solid #333; width: 200px; height: 10px; background: #111;
            margin-top: 5px; position: relative;
        }
        #noise-bar { width: 0%; height: 100%; background: var(--term-red); transition: width 0.1s; }

        #stamina-box {
            border: 1px solid #333; width: 200px; height: 10px; background: #111;
            margin-top: 5px; position: relative;
        }
        #stamina-bar { width: 100%; height: 100%; background: #00aaff; transition: width 0.1s; }

        /* --- MENUS & MODALS --- */
        #main-menu, #win-screen, #death-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); z-index: 100;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            pointer-events: auto; cursor: default;
        }

        h1 {
            color: #fff; font-size: 4rem; margin: 0; font-weight: normal;
            text-shadow: 2px 0 var(--term-red), -2px 0 var(--term-green);
            animation: glitch 1s infinite alternate;
        }

        .btn {
            background: transparent; border: 2px solid var(--term-green); color: var(--term-green);
            padding: 15px 40px; font-family: 'VT323', monospace; font-size: 1.8rem;
            cursor: pointer; margin-top: 30px; transition: all 0.2s;
            text-transform: uppercase; letter-spacing: 2px;
        }
        .btn:hover { background: var(--term-green); color: #000; box-shadow: 0 0 20px var(--term-green); }

        .key-display {
            background: #111; border: 1px dashed var(--term-green); color: var(--term-green);
            padding: 20px; font-size: 1.5rem; margin: 20px; max-width: 80%; word-break: break-all;
            text-align: center;
        }

        /* --- ANIMATIONS --- */
        @keyframes glitch {
            0% { text-shadow: 2px 0 var(--term-red), -2px 0 var(--term-green); transform: skew(0deg); }
            20% { text-shadow: 2px 0 var(--term-red), -2px 0 var(--term-green); transform: skew(0deg); }
            21% { text-shadow: -2px 0 var(--term-green), 2px 0 var(--term-red); transform: skew(10deg); }
            22% { text-shadow: 2px 0 var(--term-red), -2px 0 var(--term-green); transform: skew(0deg); }
            100% { text-shadow: 2px 0 var(--term-red), -2px 0 var(--term-green); transform: skew(0deg); }
        }

        .jumpscare {
            animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) both;
            transform: translate3d(0, 0, 0); backface-visibility: hidden;
        }
        @keyframes shake {
            10%, 90% { transform: translate3d(-1px, 0, 0); }
            20%, 80% { transform: translate3d(2px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
            40%, 60% { transform: translate3d(4px, 0, 0); }
        }

        #flash-red {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: red; opacity: 0; pointer-events: none; z-index: 90;
            mix-blend-mode: overlay; transition: opacity 0.1s;
        }
    </style>
</head>
<body>

    <div id="crt-overlay"></div>
    <div id="scanline"></div>
    <div id="vignette"></div>
    <div id="flash-red"></div>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>

        <div id="ui-layer">
            <div>
                <div class="hud-text">SIGNAL: <span id="noise-val">LOW</span></div>
                <div id="noise-meter-box"><div id="noise-bar"></div></div>
            </div>
            
            <div style="text-align: right;">
                <div class="hud-text">SYSTEM STATUS</div>
                <div style="font-size: 1rem; color: #555;">OBJ: LOCATE MASTER NODE</div>
            </div>

            <div style="position: absolute; bottom: 20px; left: 20px;">
                <div class="hud-text">STAMINA</div>
                <div id="stamina-box"><div id="stamina-bar"></div></div>
            </div>
        </div>

        <div id="main-menu">
            <h1>PROTOCOL:<br>BLACKOUT</h1>
            <p style="color: #666; font-size: 1.2rem; margin-top: -10px;">A SYSTEM RECOVERY OPERATION</p>
            <div style="margin-top: 30px; color: #888; text-align: center;">
                <p>WASD to Move | SHIFT to Run</p>
                <p>Your light is your life. But it attracts <b>HIM</b>.</p>
                <p>Find the Cyan Node. Don't let him touch you.</p>
            </div>
            <button class="btn" onclick="startGame()">INITIALIZE</button>
        </div>

        <div id="death-screen" style="display:none;">
            <h1 style="color: red; text-shadow: 0 0 20px red;">CONNECTION LOST</h1>
            <p style="color: #fff; font-size: 1.5rem;">THE PROXY CAUGHT YOU.</p>
            <button class="btn" onclick="resetGame()">REBOOT SYSTEM</button>
        </div>

        <div id="win-screen" style="display:none;">
            <h1 style="color: cyan; text-shadow: 0 0 20px cyan;">SYSTEM RESTORED</h1>
            <p style="color: #fff;">ACCESS GRANTED. COPY YOUR KEY.</p>
            
            <div id="key-container" class="key-display">FETCHING FROM SERVER...</div>
            
            <button class="btn" onclick="copyToClip()">COPY KEY</button>
            <button class="btn" onclick="resetGame()" style="border-color: #555; color: #555; margin-top: 10px;">RESTART</button>
        </div>
    </div>

    <script>
        // --- CONFIG & SETUP ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const noiseBar = document.getElementById('noise-bar');
        const staminaBar = document.getElementById('stamina-bar');
        const flashRed = document.getElementById('flash-red');
        
        // --- SERVER CONFIG (REUSE YOUR WORKER URL) ---
        const WORKER_URL = "https://powa-vault.powwa.workers.dev"; 
        
        let width, height;
        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
        }
        window.addEventListener('resize', resize);
        resize();

        // --- AUDIO ENGINE ---
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        let audioCtx = new AudioContext();
        
        function playSound(type, vol=0.1) {
            if(audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            
            const now = audioCtx.currentTime;
            
            if (type === 'step') {
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(50 + Math.random()*20, now);
                osc.frequency.exponentialRampToValueAtTime(10, now + 0.1);
                gain.gain.setValueAtTime(vol, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.start(now); osc.stop(now + 0.1);
            }
            else if (type === 'heartbeat') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(60, now);
                gain.gain.setValueAtTime(vol * 2, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                osc.start(now); osc.stop(now + 0.2);
            }
            else if (type === 'drone') {
                const bufferSize = audioCtx.sampleRate * 2.0;
                const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
                
                const noise = audioCtx.createBufferSource();
                noise.buffer = buffer;
                noise.loop = true;
                
                const biquadFilter = audioCtx.createBiquadFilter();
                biquadFilter.type = "lowpass";
                biquadFilter.frequency.value = 400;
                
                const droneGain = audioCtx.createGain();
                droneGain.gain.value = 0.05;
                
                noise.connect(biquadFilter);
                biquadFilter.connect(droneGain);
                droneGain.connect(audioCtx.destination);
                noise.start();
                return { node: noise, gain: droneGain };
            }
            else if (type === 'scream') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(200, now);
                osc.frequency.exponentialRampToValueAtTime(800, now + 0.5);
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(vol, now + 0.1);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.8);
                
                const wave = audioCtx.createWaveShaper();
                wave.curve = makeDistortionCurve(400);
                
                osc.connect(wave);
                wave.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start(now); osc.stop(now + 1);
            }
            else if (type === 'ping') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(880, now);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 1);
                osc.start(now); osc.stop(now + 1);
            }
            
            if (type !== 'drone') {
                osc.connect(gain);
                gain.connect(audioCtx.destination);
            }
        }

        function makeDistortionCurve(amount) {
            let k = typeof amount === 'number' ? amount : 50,
                n_samples = 44100,
                curve = new Float32Array(n_samples),
                deg = Math.PI / 180, i = 0, x;
            for ( ; i < n_samples; ++i ) {
                x = i * 2 / n_samples - 1;
                curve[i] = ( 3 + k ) * x * 20 * deg / ( Math.PI + k * Math.abs(x) );
            }
            return curve;
        }

        let droneAudio = null;

        // --- GAME STATE ---
        let gameState = 'MENU'; 
        const TILE_SIZE = 60;
        const MAP_SIZE = 40; 
        let map = []; 
        let walls = [];
        
        const player = { x: 0, y: 0, angle: 0, speed: 3, runSpeed: 6, stamina: 100, noise: 0 };
        const entity = { x: 0, y: 0, active: false, state: 'STALK', speed: 2.5, rage: 0, distance: 1000 };
        const keyObj = { x: 0, y: 0, collected: false };
        const keys = { w:false, a:false, s:false, d:false, Shift:false };
        let mouseX = 0, mouseY = 0;

        // --- MAP GENERATION (FIXED & SAFE) ---
        function generateMap() {
            // 1. Reset Map
            map = new Array(MAP_SIZE).fill(0).map(() => new Array(MAP_SIZE).fill(1));
            walls = [];

            // 2. Random Walker
            let x = Math.floor(MAP_SIZE/2);
            let y = Math.floor(MAP_SIZE/2);
            let steps = 800; 

            player.x = x * TILE_SIZE + TILE_SIZE/2;
            player.y = y * TILE_SIZE + TILE_SIZE/2;
            
            map[y][x] = 0;

            for(let i=0; i<steps; i++) {
                const dir = Math.floor(Math.random()*4);
                if(dir===0) y--; else if(dir===1) x++;
                else if(dir===2) y++; else if(dir===3) x--;

                if(x<1) x=1; if(x>MAP_SIZE-2) x=MAP_SIZE-2;
                if(y<1) y=1; if(y>MAP_SIZE-2) y=MAP_SIZE-2;

                map[y][x] = 0;
            }

            // 3. Place Key (Safety Logic Added)
            let placed = false;
            let attempts = 0;
            let requiredDist = 1000; 

            while(!placed && attempts < 200) {
                attempts++;
                let rx = Math.floor(Math.random()*MAP_SIZE);
                let ry = Math.floor(Math.random()*MAP_SIZE);
                
                if (map[ry][rx] === 0) {
                    let dist = Math.hypot((rx*TILE_SIZE) - player.x, (ry*TILE_SIZE) - player.y);
                    if (dist > requiredDist) {
                        keyObj.x = rx * TILE_SIZE + TILE_SIZE/2;
                        keyObj.y = ry * TILE_SIZE + TILE_SIZE/2;
                        placed = true;
                    }
                }
                if (attempts === 100) requiredDist = 500; 
            }
            if (!placed) {
                 keyObj.x = 5 * TILE_SIZE; keyObj.y = 5 * TILE_SIZE; map[5][5] = 0; 
            }

            // 4. Populate Walls
            for(let ry=0; ry<MAP_SIZE; ry++){
                for(let rx=0; rx<MAP_SIZE; rx++){
                    if(map[ry][rx] === 1) {
                        walls.push({ x: rx*TILE_SIZE, y: ry*TILE_SIZE, w: TILE_SIZE, h: TILE_SIZE });
                    }
                }
            }
            
            // 5. Spawn Entity (Safety Logic Added)
            let spawned = false;
            attempts = 0;
            requiredDist = 800;

            while(!spawned && attempts < 200) {
                attempts++;
                let ex = Math.floor(Math.random()*MAP_SIZE);
                let ey = Math.floor(Math.random()*MAP_SIZE);
                
                if(map[ey][ex] === 0) {
                    let d = Math.hypot((ex*TILE_SIZE) - player.x, (ey*TILE_SIZE) - player.y);
                    if (d > requiredDist) {
                        entity.x = ex * TILE_SIZE + TILE_SIZE/2;
                        entity.y = ey * TILE_SIZE + TILE_SIZE/2;
                        spawned = true;
                    }
                }
                if (attempts === 100) requiredDist = 400;
            }
            if (!spawned) {
                entity.x = player.x + 200; entity.y = player.y;
            }
        }

        // --- GAME LOOP ---
        function startGame() {
            document.getElementById('main-menu').style.display = 'none';
            document.getElementById('death-screen').style.display = 'none';
            document.getElementById('win-screen').style.display = 'none';
            
            if(!droneAudio) droneAudio = playSound('drone');
            
            gameState = 'PLAY';
            generateMap();
            player.stamina = 100;
            entity.state = 'STALK';
            entity.rage = 0;
            
            requestAnimationFrame(loop);
        }

        function resetGame() {
             if(droneAudio) { droneAudio.node.stop(); droneAudio = null; }
             document.getElementById('main-menu').style.display = 'flex';
             document.getElementById('death-screen').style.display = 'none';
             document.getElementById('win-screen').style.display = 'none';
             gameState = 'MENU';
        }

        function update() {
            if(gameState !== 'PLAY') return;

            let moveSpeed = player.speed;
            let isRunning = keys.Shift && player.stamina > 0;
            
            if(isRunning) {
                moveSpeed = player.runSpeed;
                player.stamina -= 0.5;
                player.noise = Math.min(player.noise + 5, 100);
            } else {
                player.stamina = Math.min(player.stamina + 0.2, 100);
                player.noise = Math.max(player.noise - 2, 0);
            }

            let dx = 0, dy = 0;
            if(keys.w) dy -= moveSpeed;
            if(keys.s) dy += moveSpeed;
            if(keys.a) dx -= moveSpeed;
            if(keys.d) dx += moveSpeed;

            let newX = player.x + dx;
            let newY = player.y + dy;
            
            if (!checkCollision(newX, player.y)) player.x = newX;
            if (!checkCollision(player.x, newY)) player.y = newY;

            if((dx !== 0 || dy !== 0) && Math.random() < (isRunning ? 0.1 : 0.05)) {
                playSound('step', isRunning ? 0.3 : 0.1);
            }

            player.angle = Math.atan2(mouseY - height/2, mouseX - width/2);

            // Entity Logic
            let distToPlayer = Math.hypot(entity.x - player.x, entity.y - player.y);
            entity.distance = distToPlayer;

            if (distToPlayer < 400 && Math.random() < 0.05) playSound('heartbeat', 1 - (distToPlayer/400));
            
            if (entity.state === 'STALK') {
                let angle = Math.atan2(player.y - entity.y, player.x - entity.x);
                angle += (Math.random()-0.5); 
                let speed = (player.noise > 50) ? 3.5 : 1.0;
                
                if (!checkCollision(entity.x + Math.cos(angle)*speed, entity.y)) entity.x += Math.cos(angle)*speed;
                if (!checkCollision(entity.x, entity.y + Math.sin(angle)*speed)) entity.y += Math.sin(angle)*speed;

                if (distToPlayer < 200) entity.state = 'CHASE';
            }
            else if (entity.state === 'CHASE') {
                let angle = Math.atan2(player.y - entity.y, player.x - entity.x);
                let speed = entity.speed + (entity.rage * 0.01);
                entity.x += Math.cos(angle) * speed;
                entity.y += Math.sin(angle) * speed;

                if (distToPlayer < 30) gameOver();
            }

            let distKey = Math.hypot(keyObj.x - player.x, keyObj.y - player.y);
            if (distKey < 40) {
                playSound('ping');
                winGame();
            }

            noiseBar.style.width = player.noise + "%";
            staminaBar.style.width = player.stamina + "%";
            noiseBar.style.backgroundColor = player.noise > 80 ? 'red' : '#33ff00';
            document.getElementById('noise-val').innerText = player.noise > 80 ? "CRITICAL" : (player.noise > 40 ? "HIGH" : "LOW");
        }

        function checkCollision(x, y) {
            let gx = Math.floor(x / TILE_SIZE);
            let gy = Math.floor(y / TILE_SIZE);
            if(map[gy][gx] === 1) return true;
            return false;
        }

        function draw() {
            ctx.fillStyle = "#000";
            ctx.fillRect(0, 0, width, height);
            
            ctx.save();
            ctx.translate(width/2 - player.x, height/2 - player.y);

            let viewRange = 1000;
            let startCol = Math.max(0, Math.floor((player.x - viewRange) / TILE_SIZE));
            let endCol = Math.min(MAP_SIZE, Math.floor((player.x + viewRange) / TILE_SIZE));
            let startRow = Math.max(0, Math.floor((player.y - viewRange) / TILE_SIZE));
            let endRow = Math.min(MAP_SIZE, Math.floor((player.y + viewRange) / TILE_SIZE));

            ctx.fillStyle = "#111";
            for(let y=startRow; y<endRow; y++) {
                for(let x=startCol; x<endCol; x++) {
                    if(map[y][x] === 0) ctx.fillRect(x*TILE_SIZE, y*TILE_SIZE, TILE_SIZE+1, TILE_SIZE+1);
                }
            }

            ctx.fillStyle = "#222";
            ctx.shadowBlur = 0;
            for(let y=startRow; y<endRow; y++) {
                for(let x=startCol; x<endCol; x++) {
                    if(map[y][x] === 1) {
                        ctx.fillRect(x*TILE_SIZE, y*TILE_SIZE, TILE_SIZE, TILE_SIZE);
                        ctx.fillStyle = "#0a0a0a";
                        ctx.fillRect(x*TILE_SIZE + 5, y*TILE_SIZE + 5, TILE_SIZE - 10, TILE_SIZE - 10);
                        ctx.fillStyle = "#222";
                    }
                }
            }

            ctx.shadowBlur = 20;
            ctx.shadowColor = "#00ffff";
            ctx.fillStyle = "#00ffff";
            ctx.beginPath();
            ctx.arc(keyObj.x, keyObj.y, 8 + Math.sin(Date.now()*0.01)*2, 0, Math.PI*2);
            ctx.fill();
            
            ctx.font = "20px VT323";
            ctx.fillStyle = "#fff";
            ctx.textAlign = "center";
            ctx.fillText("MASTER NODE", keyObj.x, keyObj.y - 20);


            let dx = entity.x - player.x;
            let dy = entity.y - player.y;
            let dist = Math.sqrt(dx*dx + dy*dy);
            let angleToEntity = Math.atan2(dy, dx);
            let angleDiff = angleToEntity - player.angle;
            while(angleDiff > Math.PI) angleDiff -= Math.PI*2;
            while(angleDiff < -Math.PI) angleDiff += Math.PI*2;
            
            let isLit = dist < 450 && Math.abs(angleDiff) < 0.6; 

            if (isLit) {
                entity.rage += 1;
                if(entity.rage > 50) entity.state = 'CHASE';
                
                ctx.shadowBlur = 10;
                ctx.shadowColor = "red";
                ctx.fillStyle = "#000";
                ctx.beginPath();
                ctx.arc(entity.x, entity.y, 20, 0, Math.PI*2);
                ctx.fill();
                
                ctx.fillStyle = "red";
                ctx.fillRect(entity.x - 8, entity.y - 5, 6, 6);
                ctx.fillRect(entity.x + 2, entity.y - 5, 6, 6);
                
                if (Math.random() > 0.8) {
                    ctx.fillStyle = "red";
                    ctx.fillRect(entity.x - 15, entity.y - 20, 30, 40);
                }
            } else {
                if (dist < 150) {
                     ctx.fillStyle = "#050505";
                     ctx.beginPath();
                     ctx.arc(entity.x, entity.y, 20, 0, Math.PI*2);
                     ctx.fill();
                }
            }

            ctx.shadowBlur = 0;
            ctx.fillStyle = "#33ff00"; 
            ctx.beginPath();
            ctx.arc(player.x, player.y, 10, 0, Math.PI*2);
            ctx.fill();

            ctx.restore();

            // --- DARKNESS MASK ---
            ctx.globalCompositeOperation = 'source-over';
            let gx = width/2;
            let gy = height/2;
            
            ctx.fillStyle = "rgba(0,0,0,0.98)"; 
            
            ctx.beginPath();
            ctx.rect(0, 0, width, height); 
            
            ctx.arc(gx, gy, 40, 0, Math.PI*2, true);
            
            ctx.moveTo(gx, gy);
            let coneDist = 450 + (Math.sin(Date.now()*0.02)*10); 
            let coneWidth = 0.5; 
            
            let startAngle = player.angle - coneWidth;
            let endAngle = player.angle + coneWidth;
            
            ctx.arc(gx, gy, coneDist, endAngle, startAngle, true);
            
            ctx.closePath();
            ctx.fill();
        }

        function loop() {
            if(gameState === 'PLAY') {
                update();
                draw();
                requestAnimationFrame(loop);
            }
        }

        function gameOver() {
            gameState = 'DEAD';
            playSound('scream', 0.8);
            flashRed.style.opacity = 1;
            document.body.classList.add('jumpscare');
            
            setTimeout(() => {
                flashRed.style.opacity = 0;
                document.body.classList.remove('jumpscare');
                document.getElementById('death-screen').style.display = 'flex';
            }, 500);
        }

        async function winGame() {
            gameState = 'WIN';
            const winScreen = document.getElementById('win-screen');
            winScreen.style.display = 'flex';
            
            const keyBox = document.getElementById('key-container');
            keyBox.innerText = "DECRYPTING...";
            keyBox.style.animation = "blink 0.5s infinite";

            try {
                const response = await fetch(WORKER_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        action: "GET_KEY",  
                        score: 999, 
                        secret: "POWA_HANDSHAKE_v1",
                        startTime: Date.now() - 60000 
                    })
                });
                const data = await response.json();

                if (response.ok && data.key) {
                    keyBox.innerText = data.key;
                    keyBox.style.color = "#33ff00"; 
                    keyBox.style.animation = "none";
                } else {
                    keyBox.innerText = data.error || "DECRYPTION FAILED";
                    keyBox.style.color = "red";
                }
            } catch (error) {
                console.error(error);
                keyBox.innerText = "SERVER UNREACHABLE";
                keyBox.style.color = "red";
            }
        }
        
        function copyToClip() {
            const txt = document.getElementById('key-container').innerText;
            navigator.clipboard.writeText(txt);
            alert("KEY COPIED TO CLIPBOARD");
        }

        window.addEventListener('keydown', e => {
            if(keys.hasOwnProperty(e.key)) keys[e.key] = true;
            if(keys.hasOwnProperty(e.key.toLowerCase())) keys[e.key.toLowerCase()] = true;
        });
        window.addEventListener('keyup', e => {
            if(keys.hasOwnProperty(e.key)) keys[e.key] = false;
            if(keys.hasOwnProperty(e.key.toLowerCase())) keys[e.key.toLowerCase()] = false;
        });
        window.addEventListener('mousemove', e => {
            mouseX = e.clientX;
            mouseY = e.clientY;
        });

    </script>
</body>
</html>
